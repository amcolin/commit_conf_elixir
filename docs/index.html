<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Elixir - Commit conf</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h3>Sistemas con alta disponibilidad en Elixir </h3>

					<p>
						<small>Anayeli Malvaez <a href="https://twitter.com/anayelimalvaez">(@AnayeliMalvaez)</a>
							y Erick Camacho <a href="https://twitter.com/ecamacho">(@ecamacho)</a></small>
					</p>
					<p>
						<small>Commit Conf 2019</small>
					</p>
				</section>

				<section data-background="img/mex-sto.png">
					<h2>Acerca de nosotros</h2>
				</section>
				<section>
					<h2>¿De qué vamos a hablar?</h2>
				</section>
				<section>
					<p><strong>Total disponibilidad</strong></p>
					<p>
						<strong>Todo</strong> funciona, <strong>todo</strong> el tiempo
					</p>
					<aside class="notes">
						Esto es imposible: el software tiene errores, el hardware falla,
						las redes fallan
					</aside>
				</section>
				<section>
					<p><strong>Alta disponibilidad</strong></p>
					<p>
						<strong>Casi</strong> todo funciona, <strong>casi</strong> todo el tiempo
					</p>
					<aside class="notes">
						A esto es a lo que podemos aspirar.
						Depende de cada sistema definir que es ese "casi" que no debe fallar.
					</aside>
				</section>
				<section>
					<p><strong>Alta disponibilidad</strong></p>
					<p>Porcentaje de tiempo que el sistema estuvo disponible durante
						el año.
					</p>
				</section>
				<section>
					<table>
						<thead>
							<tr>
								<th>Disponibilidad</th>
								<th>Tiempo no disponible en el año</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>9,99% (3s nueves)</td>
								<td>8,77 horas	</td>
							</tr>
							<tr>
								<td>9,95% (3s nueves cinco)</td>
								<td>4,38 horas</td>
							</tr>
							<tr>
								<td>9,999% (4 nueves)</td>
								<td>52,6 minutos</td>
							</tr>
							<tr>
								<td>9,9999% (5 nueves)</td>
								<td>5,26 minutos</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section>
					<img src="img/erlang.png" alt="erlang logo"/>
					<aside class="notes">
						Durante esta charla hablaremos de la plataforma Erlang (y de Elixir)
						y de las partes que nos ayudan a tener alta disponibilidad
					</aside>
				</section>
				<section>
					<img src="img/erlang_the_movie.jpg" alt="erlang creators"/>
					<aside class="notes">
						Erlang se creo en los 80's en Ericsson por
						Joe Armstrong, Robert Virdring y Mike Williams
						y se usó en un principio para Switches de telecomunicaciones
					</aside>
				</section>
				<section>
					<q>
						¿Cómo podemos programar sistemas que se comporten de forma razonable ante la presencia de errores?
					</q>
					<p><strong>Joe Armstrong, 2003, tésis de doctorado</strong></p>
				</section>
				<section>
					<img style="width: 50%;" src="img/elixir_logo.png" alt="elixir logo"/>
				</section>
				<section>
						<img src="img/elixir_beam.png" alt="erlang ecosystem"/>
				</section>
				<section>
					<img src="img/jose_valim.jpg" alt="elixir creator jose valim"/>
				</section>
				<section>
					<img src="img/companies.png" alt="empresas que usan erlang"/>
					<aside class="notes">
						Elixir ayudó a sacar a Erlang del nicho de sistemas de telecomunicaciones
						y a bajar la barrera de entrada para que nuevos programadores usaran esa plataforma.
					</aside>
				</section>
				<section>
					<h2>¿Cómo logras Alta Disponibilidad con Elixir?</h2>
					<h2 class="fragment fade-up">Con procesos</h2>
				</section>
				<section>
					<h2>Veamos un ejemplo</h2>
					<aside class="notes">
						1: Un proceso simple
						2: Paso de mensajes (ping pong)
						3: Crear muchos procesos
					</aside>
				</section>
				<section data-background="img/install.png">
				</section>
				<section>
					<h2>Demo</h2>
					<aside class="notes">
						1: Crear proyecto, listas
						2: Paso de mensajes (ping pong)
						3: Crear muchos procesos (web)
					</aside>
				</section>
				<section>
					<img style="width:70%;" src="img/beam_procesos.png" alt="procesos en la maquina virtual"/>
					<aside class="notes">
						La máquina virtual (BEAM) se encarga de gestionar los procesos a través de schedulers.
						Por default, crea un scheduler por Core del procesador.
						El hecho de tener procesos ligeros, permite hacer cambios de contexto en milisegundos
						A nivel de sistema operativo hay un solo proceso, el de la BEAM.
					</aside>
				</section>
				<section>
					<h2>La única forma de comunicar procesos es mediante paso de mensajes</h2>
				</section>
				<section>
					<h2>Los procesos son aislados</h2>
					<h2 class="fragment fade-up"><strong>Demo</strong></h2>
					<aside class="notes">
						Demo que muestra que el servicio devuelve errores pero no truena.
					</aside>
				</section>
				<section data-background="img/crash.jpg">
					<h2>Let it crash!</h2>
				</section>
				<section>
					<h2>Analogía: ¿Cómo funciona un Sistema Operativo?</h2>
				</section>
				<section data-background="img/app-crash.gif"></section>
				<section data-background="img/appcrashing.gif"></section>
				<section>
					<q>La clave para tener software tolerante a fallos es descomponer los sistemas grandes en módulos, cada módulo será una unidad de servicio
						y una unidad de fallo. Un fallo en un módulo no se propaga más allá de dicho módulo.</q>
				<p><strong>Jim Gray, 1985, Porqué las computadores se detienen y qué podemos hacer al respecto</strong></p>
				</section>
				<section>
					<p>Sin embargo, seguimos haciendo apps como si fueran Sistemas Operativos de los 60's</p>
					<p class="fragment fade-up"><strong >¿Por qué tus apps no deberían funcionar de la misma forma?</strong></h2>
				</section>
				<section>
					<h2>¡Los procesos son socialistas!</h2>
					<p class="fragment fade-up">No pueden monopolizar el CPU</p>
				</section>
				<section data-background="img/panda_slide.gif">
					<p>Pongamos un ejemplo</p>
				</section>
				<section data-background="img/panda_blocking.gif">
					<p>Un proceso podría bloquear al resto</p>
				</section>
				<section>
						<h2>¿Cómo funciona en Elixir?</h2>
						<aside class="notes">
							Demo que muestra que una tarea que ocupa mucho CPU no bloquea otras tareas
						</aside>
					</section>
					<section data-background="img/panda_unblocking.gif">
						<h2>El scheduler es preemptive* (apropiativo)</h2>
					</section>
				<section data-background="img/pandas.gif">
					<p>El scheduler es preemptive* (apropiativo)</p>
					<p>Un proceso que use muchos recursos, no bloquea a los demás.</p>
				</section>
				<section>
					<h2>Es fácil encontrar procesos problemáticos</h2>
					<h2 class="fragment fade-up"><strong>Demo</strong></h2>
					<aside class="notes">
						Demo desde IEX para detectar la función problemática y matarla
						Mostrar el observer
					</aside>
				</section>
				<section>
					<p>Los procesos tienen identidad.</p>
					<p>La identidad es el PID o su nombre.</p>
				</section>
				<section>
					<p>Entonces</p>
					<p>¿Cómo podemos programar sistemas que se comporten de forma razonable ante la presencia de errores?</p>
					<ul>
						<li  class="fragment fade-up">Procesos pequeños y aislados</li>
						<li class="fragment fade-up">Paso de mensajes</li>
						<li class="fragment fade-up">Tolerancia a fallos</li>
						<li class="fragment fade-up">Scheduler apropiativo</li>
						<li class="fragment fade-up">Debugging fácil</li>
					</ul>
				</section>
				<section>
					<p>Eso es Elixir! DAB</p>
					<p>Gracias</p>
					<p>@AnayeliMalvaez</p>
					<p>@ecamacho</p>
				</section>
			</div>

		</div>

		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
